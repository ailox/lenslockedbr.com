package models

import (
	"regexp"
	"strings"
	"time"

	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/postgres"
	"golang.org/x/crypto/bcrypt"

	"lenslockedbr.com/rand"
	"lenslockedbr.com/hash"
)

var (
	// ErrNotFound is returned when a resource cannot be found
	// in database.
	ErrNotFound modelError = "models: resource not found"

	// ErrIDInvalid is returned when an invalid ID is
	// provided to a method like Delete.
	ErrIDInvalid modelError = "models: ID provided was invalid"

	// ErrPasswordIncorrect is returned when an invalid password
	// is used when attempting to authenticate a user.
	ErrPasswordIncorrect modelError = "models: incorrect password " + 
                                          "provided"

	// ErrEmailRequired is returned when an email address is not
	// provided when creating a user
	ErrEmailRequired modelError = "models: email address is required"

	// ErrEmailInvalid is returned when an email address provided
	// does not match any of our requirements
	ErrEmailInvalid modelError = "models: email address is not valid"

	// ErrEmailTaken is returned when an update or create is attempted
	// with an email address that is already in use.
	ErrEmailTaken modelError = "models: email address is already " + 
                                   "taken"

	// ErrPasswordTooShort is returned when a user tries to set a 
	// password that is less than 8 characters long.
	ErrPasswordTooShort modelError = "models: password must be at" +
                                         " least 8 characters long"

	// ErrPasswordRequired is returned when a create is attempted
	// without a user password provided.
	ErrPasswordRequired modelError = "models: password is required"

	// ErrRememberRequired is returned when a create or update is
	// attempted without a user remember token hash
	ErrRememberRequired modelError = "models: remember token " +
                                         " is required"

	// ErrRememberTooShort is returned when a remember token is not
	// at least 32 bytes
	ErrRememberTooShort modelError = "models: remember token must " +
                            " be at least 32 bytes"

	ErrTokenInvalid modelError = "models: token provided is not valid"

	_ UserDB = &userGorm{}
	_ UserService = &userService{}
)

type User struct {
	gorm.Model
	Name         string
	Age          int
	Email        string `gorm:"not null;unique_index"`
	Password     string `gorm:"-"`
	PasswordHash string `gorm:"not null"`
	Remember     string `gorm:"-"`
	RememberHash string `gorm:"not nill;unique_index"`
}

// UserDB is used to interact with the users database.
//
// For pretty much all single user queries:
//
// If the user is found, we will return a nil error
// If the user is not found, we will return ErrNotFound
// If there is another error, we will return an error with more
// information about what went wrong. This may not be an error
// generated by the models package.
//
// For single user queries, any error but ErrNotFound should probably
// result in a 500 error until we make "public" facing errors.
type UserDB interface {

	// Methods for querying for single users
	ByID(id uint) (*User, error)
	ByEmail(email string) (*User, error)
	ByRemember(token string) (*User, error)
	ByAge(age int) (*User, error) 

	// Methods for querying multiples users
	InAgeRange(min, max int) ([]User, error)

	// Methods for altering users
	Create(user *User) error
	Update(user *User) error
	Delete(id uint) error
}

// UserService interface is a set of methods used to manipulate and
// userGorm represents our database interaction layer and implements
// the UserDB interface fully.
type userGorm struct {
	db *gorm.DB
}

// work with the user model
type UserService interface {

	UserDB

	// Authenticate will verify the provided email address
	// and password are correct. If they are correct, the
	// user corresponding to that email will be returned.
	// Otherwise you will receive either:
	// ErrNotFound, ErrPasswordIncorrect, or another error 
	// if something goes wrong.
	Authenticate(email, password string) (*User, error)

	// InitiateReset will complete all the model-related taks to
	// start the password reset process for the user with the
	// provided email address. Once completed, it will return the
	// token, or an error if there was one.
	InitiateReset(email string) (string, error)

	// CompleteReset will complete all the model-related tasks to
	// complete the password reset process for the user that the
	// token matches, including updating that user's pw.
	// If the token has expired, or if it is invalid for any other
	// reason the ErrTokenInvalid error will be returned.
	CompleteReset(token, newPw string) (*User, error)
}

type userService struct {
	UserDB
	pepper string
	pwResetDB pwResetDB
}

// userValidator is our validation layer that validates and normalizes
// data before passing it on to the next UserDB in our interface chain.
type userValidator struct {
	UserDB
	hmac hash.HMAC
	pepper string
	emailRegex *regexp.Regexp
}

type userValFn func(*User) error

func runUserValFns(user *User, fns ...userValFn) error {
	for _, fn := range fns {
		if err := fn(user); err != nil {
			return err
		}
	}

	return nil
}

type modelError string

func (e modelError) Error() string {
	return string(e)
}

func (e modelError) Public() string {
	s := strings.Replace(string(e), "models: ", "", 1)
	split := strings.Split(s, " ")
	split[0] = strings.Title(split[0])
	return strings.Join(split, " ")
}

/////////////////////////////////////////////////////////////////////
//
// METHODS
//
/////////////////////////////////////////////////////////////////////

// THIS NO LONGER RETURNS A POINTER! Interfaces can be nil, so we don't
// need to return a pointer here. Don't forget to update this first 
// line - we removed the * character at the end where we write
// (UserService, error)
func NewUserService(db *gorm.DB, pepper, hmacKey string) UserService {

	u := &userGorm{db}
	hmac := hash.NewHMAC(hmacKey)
	uv := newUserValidator(u, hmac, pepper) 

	// We also need to update how we construct the user service.
	// We no longer have a UserService type to construct, and 
	// instead need to use the userService type.
	// This IS still a pointer, as our functions implementing the
	// UserService are done with pointer receivers. eg:
	//   func (us *userService) <- this uses a pointer
	return &userService{
		UserDB: uv,
		pepper: pepper,
		pwResetDB: newPwResetValidator(&pwResetGorm{db}, hmac),
	}
}

func newUserValidator(udb UserDB, hmac hash.HMAC, pepper string) *userValidator {
	return &userValidator {
		UserDB: udb,
		hmac: hmac,
		pepper: pepper,
		emailRegex: regexp.MustCompile(
                           `^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,16}$`),
	}
}

// Create will create the provided user and backfill data like ID,
// CreatedAt, and UpdatedAt fields.
func (u *userValidator) Create(user *User) error {

	err := runUserValFns(user, u.passwordRequired,
				   u.passwordMinLength,
                                   u.bcryptPassword,
				   u.passwordHashRequired,
				   u.setRememberIfUnset,
				   u.rememberMinBytes,
                                   u.hmacRemember,
				   u.rememberHashRequired,
				   u.normalizeEmail,
				   u.requireEmail,
				   u.emailFormat,
				   u.emailIsAvail)
	if err != nil {
		return err
	}

	return u.UserDB.Create(user)
}

// Create will create the provided user and backfill data like
// the ID, CreatedAt, and UpdatedAt fields.
func (u *userGorm) Create(user *User) error {
	return u.db.Create(user).Error
}

// Update will hash a remember token if it is provided
func (u *userValidator) Update(user *User) error {

	err := runUserValFns(user, u.passwordMinLength,
                                   u.bcryptPassword,
				   u.passwordHashRequired,
				   u.rememberMinBytes,
                                   u.hmacRemember,
				   u.rememberHashRequired,
				   u.normalizeEmail,
				   u.requireEmail,
				   u.emailFormat,
				   u.emailIsAvail)
	if err != nil {
		return err
	}

	return u.UserDB.Update(user)
}

// Update will update the provided user with all of the data in
// the provided user object.
func (u *userGorm) Update(user *User) error {
	return u.db.Save(user).Error
}

// Delete will delete the user with the provided ID
func (u *userValidator) Delete(id uint) error {

	var user User
	user.ID = id

	err := runUserValFns(&user, u.idGreaterThan(0))
	if err != nil {
		return nil
	}

	return u.UserDB.Delete(id)
}

// Delete will delete the user with the provided ID
func (u *userGorm) Delete(id uint) error {
	user := User{Model: gorm.Model{ID: id}}
	return u.db.Delete(&user).Error
}

// Authenticate can be used to authenticate a user with the provided
// email address and password.
// If the email address provided is invalid, this will return
// nil, ErroNotFound
// If the password provided is invalid, this will return 
// nil. ErrPasswordIncorrect
// If the email and password are both valid, this will return
// user, nil
// Otherwise if another error is encountered this will return nil, error
func (u *userService) Authenticate(email, password string) (*User, error) {
	foundUser, err := u.ByEmail(email)
	if err != nil {
		return nil, err
	}

	err = bcrypt.CompareHashAndPassword(
			[]byte(foundUser.PasswordHash),
			[]byte(password+u.pepper))

	switch err {
	case nil:
		return foundUser, nil
	case bcrypt.ErrMismatchedHashAndPassword:
		return nil, ErrPasswordIncorrect
	default:
		return nil, err
	}
}

func (u *userService) InitiateReset(email string) (string, error) {

	user, err := u.ByEmail(email)
	if err != nil {
		return "", err
	}

	pwr := pwReset {
		UserID: user.ID,
	}
	if err := u.pwResetDB.Create(&pwr); err != nil {
		return "", err
	}

	return pwr.Token, nil
}

func (u *userService) CompleteReset(token, newPw string) (*User, error) {

	pwr, err := u.pwResetDB.ByToken(token)
	if err != nil {
		if err == ErrNotFound {
			return nil, ErrTokenInvalid
		}
		return nil, err
	}

	if time.Now().Sub(pwr.CreatedAt) > (12 * time.Hour) {
		return nil, ErrTokenInvalid
	}

	user, err := u.ByID(pwr.UserID)
	if err != nil {
		return nil, err
	}

	user.Password = newPw
	err = u.Update(user)
	if err != nil {
		return nil, err
	}
		
	u.pwResetDB.Delete(pwr.ID)

	return user, nil
}

// bcryptPassword will hash a user's password with an app-wide pepper
// and bcrypt, which salts for us.
func (u *userValidator) bcryptPassword(user *User) error {

	if user.Password == "" {
		// We DO NOT need to run this if the password
		// hasn't been changed.
		return nil
	}
	
	pwBytes := []byte(user.Password + u.pepper)
	hashedBytes, err := bcrypt.GenerateFromPassword(pwBytes, 
						bcrypt.DefaultCost)
	if err != nil {
		return err
	}

	user.PasswordHash = string(hashedBytes)
	user.Password = ""

	return nil
}

func (u *userValidator) hmacRemember(user *User) error {
	if user.Remember == "" {
		return nil
	}
	user.RememberHash = u.hmac.Hash(user.Remember)

	return nil
}

func (u *userValidator) setRememberIfUnset(user *User) error {
	if user.Remember != "" {
		return nil
	}

	token, err := rand.RememberToken()
	if err != nil {
		return err
	}

	user.Remember = token

	return nil
}

func (u *userValidator) idGreaterThan(n uint) userValFn {
	return userValFn(func(user *User) error {
		if user.ID <= n {
			return ErrIDInvalid
		}
		return nil
	})
}

func (u *userValidator) normalizeEmail(user *User) error {
	user.Email = strings.ToLower(user.Email)
	user.Email = strings.TrimSpace(user.Email)

	return nil
}

func (u *userValidator) requireEmail(user *User) error {
	if user.Email == "" {
		return ErrEmailRequired
	}

	return nil
}

func (u *userValidator) emailFormat(user *User) error {
	if user.Email == "" {
		return nil
	}

	if !u.emailRegex.MatchString(user.Email) {
		return ErrEmailInvalid
	}

	return nil
}

func (u *userValidator) emailIsAvail (user *User) error {
	existing, err := u.ByEmail(user.Email)
	if err == ErrNotFound {
		// Email address is available if we don't find
		// a user with that email address.
		return nil
	}

	// We can't continue our validation without a successful
	// query, so if we get any error other than ErrNotFound we
	// should return it.
	if err != nil {
		return err
	}

	// If we get here that means we found a user w/ this email
	// address, so we need to see if this is the same user we
	// are updating, or if we have a conflict.
	if user.ID != existing.ID {
		return ErrEmailTaken
	}

	return nil
}

func (u *userValidator) passwordMinLength(user *User) error {
	if user.Password == "" {
		return nil
	}

	if len(user.Password) < 8 {
		return ErrPasswordTooShort
	}

	return nil
}

func (u *userValidator) passwordRequired(user *User) error {
	if user.Password == "" {
		return ErrPasswordRequired
	}

	return nil
}

func (u *userValidator) passwordHashRequired(user *User) error {
	if user.PasswordHash == "" {
		return ErrPasswordRequired
	}

	return nil
}

func (u *userValidator) rememberMinBytes(user *User) error {
	if user.Remember == "" {
		return nil
	}

	n, err := rand.NBytes(user.Remember)
	if err != nil {
		return err
	}

	if n < 32 {
		return ErrRememberTooShort
	}

	return nil
}

func (u *userValidator) rememberHashRequired(user *User) error {
	if user.RememberHash == "" {
		return ErrRememberRequired
	}
	
	return nil
}
/////////////////////////////////////////////////////////////////////
//
// Query Methods
//
/////////////////////////////////////////////////////////////////////

// ByID will look up a user with the provided ID.
// If the user is found, we will return a nil error
// If the user is not found, we will return ErrNotFound
// If there is another error, we will return an error with more
// information about what went wrong.
// This may not be an error generated by the models package.
//
// As a general rule, any error but ErrNotFound should probably
// result in a 500 error.
func (u *userGorm) ByID(id uint) (*User, error) {
	var user User

	db := u.db.Where("id = ?", id)
	err := first(db, &user)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// ByEmail looks up a user with the given email address and returns
// that user.
// If the user is found, we will return a nil error
// If the user is not found, we will return ErrNotFound
// If there is another error, we will return an error with more
// information about what went wrong. This may not be an error generated
// by the models package.
func (u *userGorm) ByEmail(email string) (*User, error) {
	var user User
	db := u.db.Where("email = ?", email)
	err := first(db, &user)
	if err != nil {
		return nil, err
	}

	return &user, nil

}

// ByEmail will normalize an email address before passing it on to the
// database layer to perform the query.
func (u *userValidator) ByEmail(email string) (*User, error) {
	user := User {
		Email: email,
	}

	err := runUserValFns(&user, u.normalizeEmail)
	if err != nil {
		return nil, err
	}

	return u.UserDB.ByEmail(user.Email)
}

// ByAge will look up a user with the provided age.
// If the user is found, we will return a nil error
// If the user is not found, we will return ErrNotFound
// If there is another error, we will return an error with more
// information about what went wrong.
// This may not be an error generated by the models package.
//
// As a general rule, any error but ErrNotFound should probably
// result in a 500 error.
func (u *userGorm) ByAge(age int) (*User, error) {
	var user User
	db := u.db.Where("age = ?", age)
	err := first(db, &user)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// AgeInRange will find all the users where its age are between
// a specific range of ages
func (u *userGorm) InAgeRange(min, max int) ([]User, error) {

	users := make([]User, 0)

	db := u.db.Where("age BETWEEN ? AND ?", min, max)
	err := all(db, &users)
	if err != nil {
		return nil, err
	}

	return users, nil
}

// ByRemember looks up a user with the given remember token and returns
// that user. This method expects the remember token already hashed
func (u *userGorm) ByRemember(rememberHashed string) (*User, error) {
	var user User
	err := first(u.db.Where("remember_hash = ?", rememberHashed), 
                     &user)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// ByRemember will hash the remember token and then call ByRemember on
// the subsequent UserDB layer.
func (u *userValidator) ByRemember(token string) (*User, error) {

	user := User {
		Remember: token,
	}

	if err := runUserValFns(&user, u.hmacRemember); err != nil {
		return nil, err
	}

	return u.UserDB.ByRemember(user.RememberHash)
}

/////////////////////////////////////////////////////////////////////
//
// Helper Functions
//
/////////////////////////////////////////////////////////////////////

//
// first will query using the provided gorm.DB and it will get
// the first item returned and place it into dst. If nothing is
// found in the query, it will return ErrNotFound
//
func first(db *gorm.DB, dst interface{}) error {
	err := db.First(dst).Error
	if err == gorm.ErrRecordNotFound {
		return ErrNotFound
	}
	return err
}

func all(db *gorm.DB, dst interface{}) error {
	err := db.Find(dst).Error
	if err == gorm.ErrRecordNotFound {
		return ErrNotFound
	}
	return err
}
